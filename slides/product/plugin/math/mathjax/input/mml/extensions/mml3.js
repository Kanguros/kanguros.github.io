(function(){"use strict";var __webpack_modules__={63:function(__unused_webpack_module,exports){function createTransform(){var nodeRequire=eval("require"),dirname=eval("__dirname");try{nodeRequire.resolve("saxon-js")}catch(e){throw Error("Saxon-js not found. Run the command:\n npm install saxon-js\nand try again.")}var Saxon=nodeRequire("saxon-js"),path=nodeRequire("path"),fs=nodeRequire("fs"),xsltFile=path.resolve(dirname,"mml3.sef.json"),xslt=JSON.parse(fs.readFileSync(xsltFile));return function(e){var t;e.match(/ xmlns[=:]/)||(e=e.replace(/<(?:(\w+)(:))?math/,'<$1$2math xmlns$2$1="http://www.w3.org/1998/Math/MathML"'));try{t=Saxon.transform({stylesheetInternal:xslt,sourceText:e,destination:"serialized"}).principalResult}catch(l){t=e}return t}}Object.defineProperty(exports,"__esModule",{value:!0}),exports.createTransform=void 0,exports.createTransform=createTransform},514:function(e,t,l){var s,n=this&&this.__extends||(s=function(e,t){return(s=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var l in t)Object.prototype.hasOwnProperty.call(t,l)&&(e[l]=t[l])})(e,t)},function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Class extends value "+String(t)+" is not a constructor or null");function l(){this.constructor=e}s(e,t),e.prototype=null===t?Object.create(t):(l.prototype=t.prototype,new l)}),m=this&&this.__read||function(e,t){var l="function"==typeof Symbol&&e[Symbol.iterator];if(!l)return e;var s,n,m=l.call(e),o=[];try{for(;(void 0===t||t-- >0)&&!(s=m.next()).done;)o.push(s.value)}catch(e){n={error:e}}finally{try{s&&!s.done&&(l=m.return)&&l.call(m)}finally{if(n)throw n.error}}return o},o=this&&this.__spreadArray||function(e,t){for(var l=0,s=t.length,n=e.length;l<s ;l++,n++)e[n]=t[l];return ==typeof e&&s e.length)return{next:function(){return e},a=this&&this.__values||function(e){var l.call(e);if(e&&"number"==typeof symbol&&symbol.iterator,l=t&&e[t],s=0;if(l)return t=function>=e.length&&(e=void 0),{value:e&&e[s++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(t,"__esModule",{value:!0}),t.Mml3Handler=t.Mml3=void 0;var r=l(63),c=function(){function e(t){if("undefined"==typeof XSLTProcessor)this.transform=r.createTransform();else{var l=new XSLTProcessor,s=t.adaptor.parse(e.XSLT,"text/xml");l.importStylesheet(s),this.transform=function(e){var s=t.adaptor,n=s.parse(e),m=l.transformToDocument(n);return s.serializeXML(s.body(m))}}}return e.prototype.preFilter=function(e){e.data=this.transform(e.data)},e}();t.Mml3=c,t.Mml3Handler=function(e){return e.documentClass=function(e){function t(){for(var t,l,s=[],n=0;n<arguments n(t,e),t}(e.documentclass),e},c.xslt='\n<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"\n\t\txmlns:m="http://www.w3.org/1998/Math/MathML"\n\t\txmlns:c="http://exslt.org/common"\n\t\texclude-result-prefixes="m c">\n<xsl:output indent="yes" omit-xml-declaration="yes"/>\n<xsl:output indent="yes" omit-xml-declaration="yes"/>\n<xsl:template match="*">\n <xsl:copy>\n  <xsl:copy-of select="@*"/>\n  <xsl:apply-templates/>\n </xsl:copy>\n</xsl:template>\n<xsl:template match="m:*[@dir=\' .length;n++)s[n]=arguments[n];var c(r);d.prefilters.add(h.prefilter.bind(h)),d.options._mml3=!0}break}}}catch(e){t={error:e}}finally{try{x&&!x.done&&(l=p.return)&&l.call(p)}finally{if(t)throw d=x.value;if("MathML"===d.name){if(!d.options._mml3){var h=new p=a(i.InputJax),x=p.next();!x.done;x=p.next()){var priority=10 r=e.apply(this,o([],m(s)))||this,i=s[2];if(i.InputJax)try{for(var rtl\']" r}return t.error}}return>\n <xsl:apply-templates mode=rtl select=.>\n\n<xsl:template match=@* mode=rtl>\n <xsl:copy-of select=.>\n <xsl:attribute name=dir>ltr</xsl:attribute>\n\n<xsl:template match=* mode=rtl>\n <xsl:copy>\n <xsl:apply-templates mode=rtl select=@*>\n <xsl:for-each select=node()>\n <xsl:sort data-type=number order=descending select=position()>\n <xsl:text> </xsl:text>\n <xsl:apply-templates mode=rtl select=.>\n \n \n\n<xsl:template match=@open mode=rtl>\n <xsl:attribute name=close><xsl:value-of select=.>\n\n<xsl:template match=@open[.=\'(\'] mode=rtl>\n <xsl:attribute name=close>)</xsl:attribute>\n</xsl:template>\n<xsl:template match=@open[.=\')\'] mode=rtl>\n <xsl:attribute name=close>(</xsl:attribute>\n</xsl:template>\n<xsl:template match=@open[.=\'[\'] mode=rtl>\n <xsl:attribute name=close>]</xsl:attribute>\n</xsl:template>\n<xsl:template match=@open[.=\']\'] mode=rtl>\n <xsl:attribute name=close>[</xsl:attribute>\n</xsl:template>\n<xsl:template match=@open[.=\'{\'] mode=rtl>\n <xsl:attribute name=close>}</xsl:attribute>\n</xsl:template>\n<xsl:template match=@open[.=\'}\'] mode=rtl>\n <xsl:attribute name=close>{</xsl:attribute>\n</xsl:template>\n<xsl:template match=@close mode=rtl>\n <xsl:attribute name=open><xsl:value-of select=.>\n\n<xsl:template match=@close[.=\'(\'] mode=rtl>\n <xsl:attribute name=open>)</xsl:attribute>\n</xsl:template>\n<xsl:template match=@close[.=\')\'] mode=rtl>\n <xsl:attribute name=open>(</xsl:attribute>\n</xsl:template>\n<xsl:template match=@close[.=\'[\'] mode=rtl>\n <xsl:attribute name=open>]</xsl:attribute>\n</xsl:template>\n<xsl:template match=@close[.=\']\'] mode=rtl>\n <xsl:attribute name=open>[</xsl:attribute>\n</xsl:template>\n<xsl:template match=@close[.=\'{\'] mode=rtl>\n <xsl:attribute name=open>}</xsl:attribute>\n</xsl:template>\n<xsl:template match=@close[.=\'}\'] mode=rtl>\n <xsl:attribute name=open>{</xsl:attribute>\n</xsl:template>\n<xsl:template match=m:mfrac[@bevelled=\'true\'] mode=rtl>\n <m:mrow>\n <m:msub><m:mi></m:mi><xsl:apply-templates mode=rtl select=*[2]>\n <m:mo>\</m:mo>\n <m:msup><m:mi></m:mi><xsl:apply-templates mode=rtl select=*[1]>\n \n\n<xsl:template match=m:mfrac mode=rtl>\n <xsl:copy>\n <xsl:apply-templates mode=rtl select=@*|*>\n \n\n<xsl:template match=m:mroot mode=rtl>\n <m:msup>\n <m:menclose notation="top right">\n <xsl:apply-templates mode=rtl select=@*|*[1]>\n \n <xsl:apply-templates mode=rtl select=*[2]>\n \n\n<xsl:template match=m:msqrt mode=rtl>\n <m:menclose notation="top right">\n <xsl:apply-templates mode=rtl select=@*|*[1]>\n \n\n<xsl:template match=m:mtable|m:munder|m:mover|m:munderover mode=rtl priority=2>\n <xsl:copy>\n <xsl:apply-templates mode=rtl select=@*>\n <xsl:apply-templates mode=rtl>\n </xsl:apply-templates>\n \n\n<xsl:template match=m:msup mode=rtl priority=2>\n <m:mmultiscripts>\n <xsl:apply-templates mode=rtl select=*[1]>\n <m:mprescripts>\n <m:none>\n <xsl:apply-templates mode=rtl select=*[2]>\n \n\n<xsl:template match=m:msub mode=rtl priority=2>\n <m:mmultiscripts>\n <xsl:apply-templates mode=rtl select=*[1]>\n <m:mprescripts>\n <xsl:apply-templates mode=rtl select=*[2]>\n <m:none>\n \n\n<xsl:template match=m:msubsup mode=rtl priority=2>\n <m:mmultiscripts>\n <xsl:apply-templates mode=rtl select=*[1]>\n <m:mprescripts>\n <xsl:apply-templates mode=rtl select=*[2]>\n <xsl:apply-templates mode=rtl select=*[3]>\n \n\n<xsl:template match=m:mmultiscripts mode=rtl priority=2>\n <m:mmultiscripts>\n <xsl:apply-templates mode=rtl select=*[1]>\n <xsl:for-each select="m:mprescripts/following-sibling::*[position() mod 2 = 1]">\n <xsl:sort data-type=number order=descending select=position()>\n <xsl:apply-templates mode=rtl select=.>\n <xsl:apply-templates mode=rtl select=following-sibling::*[1]>\n \n <m:mprescripts>\n <xsl:for-each select="m:mprescripts/preceding-sibling::*[position()!=last()][position() mod 2 = 0]">\n <xsl:sort data-type=number order=descending select=position()>\n <xsl:apply-templates mode=rtl select=.>\n <xsl:apply-templates mode=rtl select=following-sibling::*[1]>\n \n \n\n<xsl:template match=m:mmultiscripts[not(m:mprescripts)] mode=rtl priority=3>\n <m:mmultiscripts>\n <xsl:apply-templates mode=rtl select=*[1]>\n <m:mprescripts>\n <xsl:for-each select="*[position() mod 2 = 0]">\n <xsl:sort data-type=number order=descending select=position()>\n <xsl:apply-templates mode=rtl select=.>\n <xsl:apply-templates mode=rtl select=following-sibling::*[1]>\n \n \n\n<xsl:template match=text()[.=\'(\'] mode=rtl>)</xsl:template>\n<xsl:template match=text()[.=\')\'] mode=rtl>(</xsl:template>\n<xsl:template match=text()[.=\'{\'] mode=rtl>}</xsl:template>\n<xsl:template match=text()[.=\'}\'] mode=rtl>{</xsl:template>\n<xsl:template match=text()[.=\'<\'] mode=rtl>></xsl:template>\n<xsl:template match="text()[.=\'>\']" mode=rtl><</xsl:template>\n<xsl:template match=text()[.=\'∈\'] mode=rtl>∋</xsl:template>\n<xsl:template match=text()[.=\'∋\'] mode=rtl>∈</xsl:template>\n<xsl:template match=@notation[.=\'radical\'] mode=rtl>\n <xsl:attribute name=notation>top right</xsl:attribute>\n</xsl:template>\n<xsl:template match=m:mlongdiv|m:mstack mode=rtl>\n <m:mrow dir=ltr>\n <xsl:apply-templates select=.>\n \n\n<xsl:template match=m:mstack priority=11>\n <xsl:variable name=m>\n <m:mtable columnspacing=0em rowspacing=0em>\n <xsl:copy-of select=@align>\n <xsl:variable name=t>\n <xsl:apply-templates mode=mstack1 select=*>\n <xsl:with-param name=p select=0>\n \n \n <xsl:variable name=maxl>\n <xsl:for-each select=c:node-set($t)/*/@l>\n <xsl:sort data-type=number order=descending>\n <xsl:if test=position()=1>\n <xsl:value-of select=.>\n \n \n \n <xsl:for-each select="c:node-set($t)/*[not(@class=\'mscarries\') or following-sibling::*[1]/@class=\'mscarries\']">\n<xsl:variable name=c select=preceding-sibling::*[1][@class=\'mscarries\']>\n <xsl:text> </xsl:text>\n <m:mtr>\n <xsl:copy-of select=@class[.=\'msline\']>\n <xsl:variable select="$maxl - @l" name=offset>\n <xsl:choose>\n <xsl:when test="@class=\'msline\' and @l=\'*\'">\n <xsl:variable name=msl select=*[1]>\n <xsl:for-each select=(//node())[position()<=$maxl]>\n <xsl:copy-of select=$msl>\n \n \n <xsl:when test=$c>\n <xsl:variable select="$c/@l - @l" name=ldiff>\n <xsl:variable select="$maxl - $c/@l" name=loffset>\n <xsl:for-each select="(//*)[position()<= $offset]">\n <xsl:variable name=pn select=position()>\n <xsl:variable select="$c/*[position()=$pn - $loffset]" name=cy>\n\t <m:mtd>\n\t <xsl:if test=$cy/*>\n\t <m:mover><m:mphantom><m:mn>0</m:mn></m:mphantom><m:mpadded lspace=-0.5width width=0em>\n\t <xsl:copy-of select=$cy/*>\n\t \n\t \n \n <xsl:for-each select=*>\n <xsl:variable name=pn select=position()>\n <xsl:variable select="$c/*[position()=$pn + $ldiff]" name=cy>\n <xsl:copy>\n\t<xsl:copy-of select=@*>\n\t<xsl:variable name=b>\n\t <xsl:choose>\n\t <xsl:when test="not(string($cy/@crossout) or $cy/@crossout=\'none\')"><xsl:copy-of select=*>\n\t <xsl:otherwise>\n\t <m:menclose notation={$cy/@crossout}><xsl:copy-of select=*>\n\t \n\t \n\t\n\t<xsl:choose>\n\t <xsl:when test="$cy/m:none or not($cy/*)"><xsl:copy-of select=$b>\n\t <xsl:when test="not(string($cy/@location)) or $cy/@location=\'n\'">\n\t <m:mover>\n\t <xsl:copy-of select=$b><m:mpadded lspace=-0.5width width=0em>\n\t <xsl:copy-of select=$cy/*>\n\t \n\t \n\t \n\t <xsl:when test=$cy/@location=\'nw\'>\n\t <m:mmultiscripts><xsl:copy-of select=$b><m:mprescripts><m:none><m:mpadded lspace=-1width width=0em><xsl:copy-of select=$cy/*>\n\t \n\t <xsl:when test=$cy/@location=\'s\'>\n\t <m:munder><xsl:copy-of select=$b><m:mpadded lspace=-0.5width width=0em><xsl:copy-of select=$cy/*>\n\t \n\t <xsl:when test=$cy/@location=\'sw\'>\n\t <m:mmultiscripts><xsl:copy-of select=$b><m:mprescripts><m:mpadded lspace=-1width width=0em><xsl:copy-of select=$cy/*><m:none>\n\t \n\t <xsl:when test=$cy/@location=\'ne\'>\n\t <m:msup><xsl:copy-of select=$b><m:mpadded width=0em><xsl:copy-of select=$cy/*>\n\t \n\t <xsl:when test=$cy/@location=\'se\'>\n\t <m:msub><xsl:copy-of select=$b><m:mpadded width=0em><xsl:copy-of select=$cy/*>\n\t \n\t <xsl:when test=$cy/@location=\'w\'>\n\t <m:msup><m:mrow><m:mpadded lspace=-1width width=0em><xsl:copy-of select=$cy/*>\n\t <xsl:copy-of select=$b>\n\t \n\t <xsl:when test=$cy/@location=\'e\'>\n\t <xsl:copy-of select=$b>\n\t <m:msup><m:mrow><m:mpadded width=0em><xsl:copy-of select=$cy/*>\n\t \n\t <xsl:otherwise>\n\t <xsl:copy-of select=$b>\n\t \n\t\n \n \n \n <xsl:otherwise>\n <xsl:for-each select="(//*)[position()<= $offset]"><m:mtd>\n <xsl:copy-of select=*>\n \n \n \n \n \n\n<xsl:apply-templates mode=ml select=c:node-set($m)>\n\n<xsl:template match=m:none mode=ml>\n<m:mrow>\n\n<xsl:template match=* mode=ml>\n <xsl:copy>\n <xsl:copy-of select=@*>\n <xsl:apply-templates mode=ml>\n \n\n<xsl:template match=m:mtr[following-sibling::*[1][@class=\'msline\']] mode=ml>\n <m:mtr>\n <xsl:copy-of select=@*>\n <xsl:variable name=m select=following-sibling::*[1]/m:mtd>\n <xsl:for-each select=m:mtd>\n <xsl:variable name=p select=position()>\n <m:mtd>\n <xsl:copy-of select=@*>\n <xsl:choose>\n <xsl:when test=$m[$p]/m:mpadded>\n <m:menclose notation=bottom>\n <m:mpadded depth=.1em height=1em width=.5em>\n\t<xsl:copy-of select=*>\n \n \n \n <xsl:otherwise>\n <xsl:copy-of select=*>\n \n \n \n \n \n\n<xsl:template match=m:mtr[not(preceding-sibling::*)][@class=\'msline\'] mode=ml priority=3>\n <m:mtr>\n <xsl:copy-of select=@*>\n <xsl:for-each select=m:mtd>\n <m:mtd>\n <xsl:copy-of select=@*>\n <xsl:if test=m:mpadded>\n <m:menclose notation=bottom>\n <m:mpadded depth=.1em height=1em width=.5em>\n <m:mspace width=.2em>\n \n \n \n \n \n \n\n<xsl:template match=m:mtr[@class=\'msline\'] mode=ml priority=2>\n<xsl:template match=* mode=mstack1>\n <xsl:param name=p>\n <xsl:param name=maxl select=0>\n <m:mtr l="{1 + $p}">\n <xsl:if test=ancestor::mstack[1]/@stackalign=\'left\'>\n <xsl:attribute name=l><xsl:value-of select=$p>\n \n <m:mtd><xsl:apply-templates select=.>\n \n\n<xsl:template match=m:msrow mode=mstack1>\n <xsl:param name=p>\n <xsl:param name=maxl select=0>\n <xsl:variable name=align1 select=ancestor::m:mstack[1]/@stackalign>\n <xsl:variable name=align>\n <xsl:choose>\n <xsl:when test=string($align1)=\'\'>decimalpoint</xsl:when>\n <xsl:otherwise><xsl:value-of select=$align1>\n \n \n <xsl:variable name=row>\n <xsl:apply-templates mode=mstack1 select=*>\n <xsl:with-param name=p select=0>\n \n \n <xsl:text> </xsl:text>\n <xsl:variable name=l1>\n <xsl:choose>\n <xsl:when test="$align=\'decimalpoint\' and m:mn">\n <xsl:for-each select=c:node-set($row)/m:mtr[m:mtd/m:mn][1]>\n <xsl:value-of select=number(sum(@l))+count(preceding-sibling::*/@l)>\n \n \n <xsl:when test="$align=\'right\' or $align=\'decimalpoint\'">\n <xsl:value-of select=count(c:node-set($row)/m:mtr/m:mtd)>\n \n <xsl:otherwise>\n <xsl:value-of select=0>\n \n \n \n <m:mtr l="{number($l1) + number(sum(@position)) +$p}" class=msrow>\n <xsl:copy-of select=c:node-set($row)/m:mtr/*>\n \n\n<xsl:template match=m:mn mode=mstack1>\n <xsl:param name=p>\n <xsl:variable name=align1 select=ancestor::m:mstack[1]/@stackalign>\n <xsl:variable name=dp1 select=ancestor::*[@decimalpoint][1]/@decimalpoint>\n <xsl:variable name=align>\n <xsl:choose>\n <xsl:when test=string($align1)=\'\'>decimalpoint</xsl:when>\n <xsl:otherwise><xsl:value-of select=$align1>\n \n \n <xsl:variable name=dp>\n <xsl:choose>\n <xsl:when test=string($dp1)=\'\'>.</xsl:when>\n <xsl:otherwise><xsl:value-of select=$dp1>\n \n \n <m:mtr l=$p>\n <xsl:variable name=mn select=normalize-space(.)>\n <xsl:variable name=len select=string-length($mn)>\n <xsl:choose>\n <xsl:when test="$align=\'right\' or ($align=\'decimalpoint\' and not(contains($mn,$dp)))">\n <xsl:attribute name=l><xsl:value-of select="$p + $len">\n \n <xsl:when test=$align=\'center\'>\n <xsl:attribute name=l><xsl:value-of select="round(($p + $len) div 2)">\n \n <xsl:when test=$align=\'decimalpoint\'>\n <xsl:attribute name=l><xsl:value-of select="$p + string-length(substring-before($mn,$dp))">\n \n <xsl:for-each select="(//node())[position() <=$len]">\n <xsl:variable name=pos select=position()>\n <m:mtd><m:mn><xsl:value-of select=substring($mn,$pos,1)>\n \n \n\n<xsl:template match=m:msgroup mode=mstack1>\n <xsl:param name=p>\n <xsl:variable name=s select=number(sum(@shift))>\n <xsl:variable name=thisp select=number(sum(@position))>\n <xsl:for-each select=*>\n <xsl:apply-templates mode=mstack1 select=.>\n <xsl:with-param name=p select=number($p)+$thisp+(position()-1)*$s>\n \n \n\n<xsl:template match=m:msline mode=mstack1>\n <xsl:param name=p>\n <xsl:variable name=align1 select=ancestor::m:mstack[1]/@stackalign>\n <xsl:variable name=align>\n <xsl:choose>\n <xsl:when test=string($align1)=\'\'>decimalpoint</xsl:when>\n <xsl:otherwise><xsl:value-of select=$align1>\n \n \n <m:mtr class=msline>\n <xsl:attribute name=l>\n <xsl:choose>\n <xsl:when test="not(string(@length)) or @length=0">*</xsl:when>\n <xsl:when test="string($align)=\'right\' or string($align)=\'decimalpoint\' "><xsl:value-of select="$p+ @length">\n <xsl:otherwise><xsl:value-of select=$p>\n \n \n <xsl:variable name=w>\n <xsl:choose>\n <xsl:when test=@mslinethickness=\'thin\'>0.1em</xsl:when>\n <xsl:when test=@mslinethickness=\'medium\'>0.15em</xsl:when>\n <xsl:when test=@mslinethickness=\'thick\'>0.2em</xsl:when>\n <xsl:when test=@mslinethickness><xsl:value-of select=@mslinethickness>\n <xsl:otherwise>0.15em</xsl:otherwise>\n \n \n <xsl:choose>\n <xsl:when test="not(string(@length)) or @length=0">\n <m:mtd class=mslinemax>\n <m:mpadded height=0em lspace=-0.2em width=0em>\n <m:mfrac linethickness={$w}>\n <m:mspace width=.5em>\n <m:mrow>\n \n \n \n \n <xsl:otherwise>\n <xsl:variable name=l select=@length>\n <xsl:for-each select=(//node())[position()<=$l]>\n <m:mtd class=msline>\n <m:mpadded height=0em lspace=-0.2em width=0em>\n <m:mfrac linethickness={$w}>\n\t<m:mspace width=.5em>\n\t<m:mrow>\n \n \n \n \n \n \n \n\n<xsl:template match=m:mscarries mode=mstack1>\n <xsl:param name=p>\n <xsl:variable name=align1 select=ancestor::m:mstack[1]/@stackalign>\n <xsl:variable name=l1>\n <xsl:choose>\n <xsl:when test=string($align1)=\'left\'>0</xsl:when>\n <xsl:otherwise><xsl:value-of select=count(*)>\n \n \n <m:mtr l="{$p + $l1 + sum(@position)}" class=mscarries>\n <xsl:apply-templates mode=msc select=*>\n \n\n<xsl:template match=* mode=msc>\n <m:mtd>\n <xsl:copy-of select=../@location|../@crossout>\n <xsl:choose>\n <xsl:when test=../@scriptsizemultiplier>\n <m:mstyle mathsize="{round(../@scriptsizemultiplier div .007)}%">\n <xsl:apply-templates select=.>\n \n \n <xsl:otherwise>\n <xsl:apply-templates select=.>\n \n \n \n\n<xsl:template match=m:mscarry mode=msc>\n <m:mtd>\n <xsl:copy-of select=@location|@crossout>\n <xsl:choose>\n <xsl:when test=../@scriptsizemultiplier>\n <m:mstyle mathsize="{round(../@scriptsizemultiplier div .007)}%">\n <xsl:apply-templates>\n \n \n <xsl:otherwise>\n <xsl:apply-templates>\n \n \n \n\n<xsl:template match=m:mlongdiv priority=11>\n <xsl:variable name=ms>\n <m:mstack>\n <xsl:copy-of select=(ancestor-or-self::*/@decimalpoint)[last()]>\n <xsl:choose>\n <xsl:when test=@longdivstyle=\'left)(right\'>\n <m:msrow>\n <m:mrow><xsl:copy-of select=*[1]>\n <m:mo>)</m:mo>\n <xsl:copy-of select=*[3]>\n <m:mo>(</m:mo>\n <xsl:copy-of select=*[2]>\n \n \n <xsl:when test=@longdivstyle=\'left/\right\'>\n <m:msrow>\n <m:mrow><xsl:copy-of select=*[1]>\n <m:mo>/</m:mo>\n <xsl:copy-of select=*[3]>\n <m:mo></m:mo>\n <xsl:copy-of select=*[2]>\n \n \n <xsl:when test=@longdivstyle=\':right=right\'>\n <m:msrow>\n <xsl:copy-of select=*[3]>\n <m:mo>:</m:mo>\n <xsl:copy-of select=*[1]>\n <m:mo>=</m:mo>\n <xsl:copy-of select=*[2]>\n \n \n <xsl:when test="@longdivstyle=\'stackedrightright\'\n\t\t    or @longdivstyle=\'mediumstackedrightright\'\n\t\t    or @longdivstyle=\'shortstackedrightright\'\n\t\t    or @longdivstyle=\'stackedleftleft\'\n\t\t    ">\n <xsl:attribute name=align>top</xsl:attribute>\n <xsl:copy-of select=*[3]>\n \n <xsl:when test=@longdivstyle=\'stackedleftlinetop\'>\n <xsl:copy-of select=*[2]>\n <m:msline length={string-length(*[3])-1}>\n <m:msrow>\n <m:mrow>\n <m:menclose notation="bottom right">\n <xsl:copy-of select=*[1]>\n \n \n <xsl:copy-of select=*[3]>\n \n \n <xsl:when test=@longdivstyle=\'righttop\'>\n <xsl:copy-of select=*[2]>\n <m:msline length={string-length(*[3])}>\n <m:msrow>\n <xsl:copy-of select=*[3]>\n <m:menclose notation="top left bottom">\n <xsl:copy-of select=*[1]>\n \n \n <xsl:otherwise>\n <xsl:copy-of select=*[2]>\n <m:msline length={string-length(*[3])}>\n <m:msrow>\n <m:mrow><xsl:copy-of select=*[1]>\n <m:mo>)</m:mo>\n <xsl:copy-of select=*[3]>\n \n \n \n <xsl:copy-of select="*[position()>3]">\n \n \n <xsl:choose>\n <xsl:when test=@longdivstyle=\'stackedrightright\'>\n <m:menclose notation=right>\n <xsl:apply-templates select=c:node-set($ms)>\n \n <m:mtable align=top>\n <m:mtr>\n <m:menclose notation=bottom>\n <xsl:copy-of select=*[1]>\n \n \n <m:mtr>\n <mtd><xsl:copy-of select=*[2]>\n \n \n \n <xsl:when test=@longdivstyle=\'mediumstackedrightright\'>\n <xsl:apply-templates select=c:node-set($ms)>\n <m:menclose notation=left>\n <m:mtable align=top>\n <m:mtr>\n <m:menclose notation=bottom>\n <xsl:copy-of select=*[1]>\n \n \n <m:mtr>\n <mtd><xsl:copy-of select=*[2]>\n \n \n \n \n <xsl:when test=@longdivstyle=\'shortstackedrightright\'>\n <xsl:apply-templates select=c:node-set($ms)>\n <m:mtable align=top>\n <m:mtr>\n <m:menclose notation="left bottom">\n <xsl:copy-of select=*[1]>\n \n \n <m:mtr>\n <mtd><xsl:copy-of select=*[2]>\n \n \n \n <xsl:when test=@longdivstyle=\'stackedleftleft\'>\n <m:mtable align=top>\n <m:mtr>\n <m:menclose notation=bottom>\n <xsl:copy-of select=*[1]>\n \n \n <m:mtr>\n <mtd><xsl:copy-of select=*[2]>\n \n \n <m:menclose notation=left>\n <xsl:apply-templates select=c:node-set($ms)>\n \n \n <xsl:otherwise>\n <xsl:apply-templates select=c:node-set($ms)>\n \n \n\n<xsl:template match=m:menclose[@notation=\'madruwb\'] mode=rtl>\n <m:menclose notation="bottom right">\n <xsl:apply-templates mode=rtl>\n \n\n\n'},955:function(e,t){MathJax._.components.global.isObject,MathJax._.components.global.combineConfig,MathJax._.components.global.combineDefaults,t.r8=MathJax._.components.global.combineWithMathJax,MathJax._.components.global.MathJax}},__webpack_module_cache__={};function __webpack_require__(e){var t=__webpack_module_cache__[e];if(void 0!==t)return t.exports;var l=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e].call(l.exports,l,l.exports,__webpack_require__),l.exports}var __webpack_exports__={},global,mml3_node,mml3;global=__webpack_require__(955),mml3_node=__webpack_require__(63),mml3=__webpack_require__(514),(0,global.r8)({_:{input:{mathml:{mml3:{"mml3-node":mml3_node,mml3:mml3}}}}}),MathJax.startup&&MathJax.startup.extendHandler((function(e){return(0,mml3.Mml3Handler)(e)}))})();